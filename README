cbnaya
geller


=============================
=      Files description    =
=============================
Sjavac.java - 	The main class, which all the others, and validates whether a 
				s-java file is alright.

Token.java - 		Representing a token in the s-java language.
Tokenizer.java - 	An iterator of s-java tokens.
Position.java - 	Representing a location in a file.

Parser.java - 					Parses a s-java file and returns an abstract 
								syntax tree representing the code.
ComplexItrator.java - 			An iterator which keeps its last returned 
								value. 
ParsingFailedException.java -	Thrown if the parsing failed.
OtherTokenTypeNeedHereException.java - 	Thrown when expecting a specific token, 
										but another appears.
NotAllowedInThisContextException.java - 	Thrown if a token unrelated to the 
											context was parsed.
InvalidIdentityNameException.java - 		Thrown when trying to name a method 
											or a variable with invalid name.


AstNode.java - 			Representing a node in an abstract syntax tree.
ScopeNode.java -		A code block like global, if, while and methods.
GlobalNode.java - 		Representing the AST root, the global code scope.
MethodNode.java - 		A method declaration.
ArgumentNode.java -		An argument of a method, extends VarDeclarationNode.
ConditionalNode.java - 	An inner block, starts with a condition.
IfNode.java, WhileNode.java - Conditional nodes. 
ExpressionNode.java - 	Representing an expression.
LiteralExpressionNode.java - 	A specific value expression, like a number, 
								true, a character, etc..
VarExpressionNode.java - 		An expression of referencing a name of a 
								variable.
BinaryOpNode.java - 	A node of boolean binary oprator, consiting two 
						expressions.
AndNode.java - 			"&&" binary operator.
OrNode.java - 			"||" binary operator.
VarDeclarationNode.java - 	Representing a declaration of a variable.
AssignmentNode.java - 	Representing an assignment of a variable with an
						expression.  
CallMethodNode.java - 	A node for calling a method.
ReturnNode.java - 		Representing a return statement.

AstValidator.java - 	Checks the state of the program is valid step by step.
VarStack.java - 		Keeps the state of the code.
Variable.java -			VarStack element.
InvalidCodeException.java - 	Is thrown when there's some problem regarding a 
								s-java file.
TypeMismatchException.java - 	Is thrown when trying to assign a variable,
								argument or a condition with a wring type.
MethodException.java, VariableException.java -	Abstract extensions of 
												InvalidCodeException.
MethodDoesNotExistException.java, MissingReturnException.java, 
ArgumentsNumMismatchException.java - 			Types of MethodException.
FinalAssignmentException.java, VarDoesNotExistException.java, 
VarDuplicateException.java, VarNeverAssignedException.java - 
												Types of VariableException.


=============================
=          Design           =
=============================
--------- our design ---------
Our design suggests several steps for validating a s-java file:
1.  lexer - The first part of the code analysis is the Lexical analysis. In this
    process we convert the code to sequence of tokens, i.e. meaningful strings. 
    Each token is atom in the language syntax e.g. the key word "if", open 
    parentheses, identity, new line and so on. For each token we save the 
    string, the type, and the position. This way, we convert a file to sequence 
    of tokens. in case we want to extends the language in this part we need only 
    add token types, by adding corresponding regex patterns.
2.  parser - The second part of the code analysis is to build an AST (Abstract 
	Syntax Tree) from the sequence of tokens. AST is a bijective tree 
	representation of the abstract syntactic structure of source code. Each code 
	could have only one way to be interpreted as a tree and vice versa. If the 
	building the AST is a success, it is ensured that the code syntax structure 
	is valid, i.e. while statements, all the brackets and so on are OK. it is 
	not enough to ensure that the code is OK, since types, duplicate declaration 
	and other problems involving names references are not checked yet,
3.  validator - The last part of the analysis is "running the code" and check it 
	is ok. we going over the AST, in a manner that represents running the code, 
	and keeping the variables,their state - initialized or not - and the scope 
	of their declaration. This way we validate the tree, and if no exception was 
	thrown during the process, it means the whole code is valid.

--------- alternative design ---------
We could have used regex for full lines, which will save us the need of 
validating lines break and and will allow us to know the specific context for 
each line, but we preferred short tokens to make the parser simpler and 
flexible.
We could have also read the file more directly, instead of turning it into a 
tree and validating it back and forth. However, the need to allow a method to 
call predefined methods and global variables made us to think of way of parsing 
the code as it is, and then access it again easily enough.
We had a dilemma regarding checking the AST by the nodes themselves, but decided 
to do it externally, to keep the modularity between the syntax and and the run, 
which also lets us to keep the state as a VarStack field of AstValidator and not 
passing it as a parameter each recursive call inside a node.

========= extents language =========
--------- add float type ---------
To add new variable types, we have to:
1. 	Update the lexer to recognize the new type as var type instead of identity.
2.	If the new type have a corresponding literal data:
	a.	Add new token type (with a corresponding regex) to the lexer. 
	b.	Update the isLiteralData parser function to recognize this token as 
		literal data. 
3.	Add the new type to the ExpressionType enum of the ast nodes.

For example, float numbers will require us to add 2 patterns - "float\\b" that
recognize the "float" key word and "-?\\d+\\.\\d+f" that recognize the float
literal values , and the expression type "FLOAT". In addition, we should also
update the ExpressionNode.ExpressionType.accept method, to allow conversions
between the new and the existing types. If a lot of conversions are allowed in
the expanded language, we might think of a new way for accept() to work, since
the relatively-simple boolean expression it returns will get ugly. The problem
is java does not allow us to keep a list of types for each type at the enum 
declaration.

--------- add switch syntax ---------
Supporting switch statements means we need to add tokens for the key words:
*   switch
*   case
*   default
*   break
We need to create SwitchNode, with a List<CaseNode> as its children, when 
CaseNode has a variable expression and a literal expression to be compared, and 
a body. Each ScopeNode will be connected to previous scopes since the last break 
statement. Parsing and validating will be updated accordingly, verifying the 
syntax is as required before creating this node and the type of the variable is 
accepted by BOOLEAN.

--------- add binary operations ---------
Supporting binary operators requires extending BinaryOpNode and creating a
similar abstract UnaryOpNode with one expression child, adding the operators 
names and patterns to the correct enums, making the parser check them at every 
creation of an expression and making the validator to make sure the operators
arguments are of the right types, according to the operator rule.
Forcing precedence require even more complicated parsing, to determine how nodes
of different operators are nested. For example, "1+2*3" will create multiply
node with int literal and addition-op nodes as children, and the "+" will have
two literal expressions as children. An int field for this types of op-nodes
will be needed.

=============================
=  Implementation details   =
=============================
Each token object kept its original position in the file, which was passed to 
the AST nodes, so when a problem is found it is easy to find where it happened 
and report this position in the message of the thrown exception. It's a lot 
easier to pass all the data of a problem back to the main module using an 
exception object, so we used this mechanism as advised.

At the validator, we had to create the global level of the stack each time,
to match the requirement of ignoring changes done to global variables at methods
and the general assume the order of method declarations is not considered.

Except for the "\\w" pattern we used for identity names (variables and methods),
we have no "main regular expressions". Our implementation of the lexer made it 
easier not to use a lot of regex, and instead read each word as a token from the 
predefined list, so we only have to check which token it was at the parser at a
switch-case block, and it is possible for each token to appear in only a few
parsing methods.